# Computing different normalization schemes in R
```{r}
# The original data can found from recount2 database (https://jhubiostatistics.shinyapps.io/recount/) using SRA project code SRP029880.
# colorectal cancer
counts_file <- system.file('extdata/rna-seq/SRP029880.raw_counts.tsv',package = 'compGenomRData')
coldata_file <- system.file('extdata/rna-seq/SRP029880.colData.tsv',package = 'compGenomRData')
counts <- as.matrix(read.table(counts_file, header = T, sep = '\t'))
#
# Computing CPM
cpm <- apply(subset(counts, select = c(-width)), 2 ,function(x) x/sum(as.numeric(x)) * 10^6)
colSums(cpm)
#
# Computing RPKM
# Create a vector of gene lengths
geneLengths <- as.vector(subset(counts, select = c(width)))
# compute rpkm
rpkm <- apply(X = subset(counts, select = c(-width)), MARGIN = 2, FUN = function(x) {
                  10^9 * x / geneLengths / sum(as.numeric(x))})
colSums(rpkm)
#
# Computing TPM
# find gene length normalised values
rpk <- apply( subset(counts, select = c(-width)), 2 , function(x) x/(geneLengths/1000))
# normalised by sample size using rpk values
tpm <- apply(rpk, 2 , function(x) x / sum(as.numeric(x)) * 10^6)
colSums(tpm)
#
# Clustering
# Let’s select the top 100 most variable genes among the samples
# compute the variance of each gene across samples
V <- apply(tpm, 1, var)
# sort the results by variance in decreasing order
# and select the top 100 genes
selectedGenes <- names(V[order(V, decreasing = T)][1:100])
# we can quickly produce a heatmap where samples and genes are clustered
pm, 1, var)
#sort the results by variance in decreasing order
#and select the top 100 genes
selectedGenes <- names(V[order(V, decreasing = T)][1:100])
# we can quickly produce a heatmap where samples and genes are clustered
library(pheatmap)
pheatmap(tpm[selectedGenes,], scale = 'row', show_rownames = FALSE)
# We can also overlay some annotation tracks to observe the clusters
colData <- read.table(coldata_file, header = T, sep = '\t',
stringsAsFactors = TRUE)
pheatmap(tpm[selectedGenes,], scale = 'row',
show_rownames = FALSE,
annotation_col = colData)
#
# PCA
# Let’s make a PCA plot to see the clustering of replicates as a scatter plot in two dimensions
library(stats)
library(ggplot2)
library(ggfortify)
M <- t(tpm[selectedGenes,])
# transform the counts to log2 scale
M <- log2(M + 1)
# compute PCA
pcaResults <- prcomp(M)
# plot PCA results making use of ggplot2's autoplot function
# ggfortify is needed to let ggplot2 know about PCA data structure.
autoplot(pcaResults, data = colData, colour = 'group')
summary(pcaResults)
#
# Corellation plots
correlationMatrix <- cor(tpm)
library(corrplot)
corrplot(correlationMatrix, order = 'hclust' ,
              addrect = 2, addCoef.col = 'white',
              number.cex = 0.7)
# We could also plot this correlation matrix as a heatmap. Heatmap instead of a corrplot helps to see the differences between samples more easily. The annotation_col argument helps to display sample annotations and the cutree_cols argument is set to 2 to split the clusters into two groups based on the hierarchical clustering results.
# split the clusters into two based on the clustering similarity
pheatmap(correlationMatrix, annotation_col = colData, cutree_cols = 2)













```
#
